# **Умножение матрицы на вектор с использованием вертикальной ленточной схемы**

- **Студент**: Артюшкина Юлия Дмитриевна, группа 3823Б1ПР4
- **Технология**: SEQ | MPI  
- **Вариант**: 12

## 1. Введение
Умножение матрицы на вектор является одной из фундаментальных операций в линейной алгебре и вычислительной математике, находящей применение в:
- Решении систем линейных уравнений
- Преобразованиях в компьютерной графике
- Анализе данных и машинном обучении
- Моделировании физических процессов

Для больших матриц последовательное умножение становится вычислительно затратным, что обуславливает необходимость применения параллельных вычислений с использованием MPI.

## 2. Постановка задачи
Дана матрица A размером M×N (тип `double`) и вектор x размером N (тип `double`).

Требуется вычислить вектор b = A × x, где каждый элемент bᵢ вычисляется как скалярное произведение i-й строки матрицы A на вектор x.

**Тип входных данных**:
```cpp
using InType = std::pair<std::vector<std::vector<double>>, std::vector<double>>;
```

**Тип выходных данных**:
```cpp
using OutType = std::vector<double>;
```

**Ограничения**:
- M, N > 0
- Все строки матрицы имеют одинаковую длину N
- Размер вектора равен количеству столбцов матрицы (N)

## 3. Базовый алгоритм (Sequential)
Классический алгоритм умножения матрицы на вектор:
```cpp
for (int i = 0; i < rows; ++i) {
    double sum = 0.0;
    for (int j = 0; j < cols; ++j) {
        sum += matrix[i][j] * vector[j];
    }
    result[i] = sum;
}
```
**Сложность алгоритма**: O(M × N)

## 4. Схема распараллеливания
### 4.1 Вертикальная ленточная схема
Матрица A разбивается на вертикальные полосы (столбцы), которые распределяются между процессами. Каждый процесс получает:
- Полную копию вектора x
- Свою полосу столбцов матрицы A
- Вычисляет частичную сумму для каждой строки
- Результаты суммируются для получения итогового вектора

### 4.2 Алгоритм распределения
```cpp
int base = cols / world_size;
int rem = cols % world_size;
int my_start = rank * base + (rank < rem ? rank : rem);
int my_width = base + (rank < rem ? 1 : 0);
```

### 4.3 Схема параллельной работы
1. **Распределение данных**: 
   - Процесс 0 рассылает матрицу всем процессам
   - Столбцы вектора распределяются по процессам в соответствии с их полосами

2. **Локальные вычисления**:
   ```cpp
   for (int i = 0; i < rows; ++i) {
       for (int j = 0; j < my_width; ++j) {
           local_result[i] += matrix[i][my_start + j] * local_vector[j];
       }
   }
   ```

3. **Сбор результатов**:
   - Каждый процесс отправляет свой частичный результат процессу 0
   - Процесс 0 суммирует все частичные результаты

4. **Рассылка финального результата**:
   - Процесс 0 рассылает итоговый вектор всем процессам

## 5. Детали реализации
| Файл | Назначение |
|------|------------|
| `common.hpp` | Определение типов данных (InType, OutType, TestType) |
| `ops_seq.hpp/.cpp` | Последовательная реализация умножения |
| `ops_mpi.hpp/.cpp` | MPI-реализация с вертикальной ленточной схемой |
| `func_tests.cpp` | 7 функциональных тестов для проверки корректности |
| `perf_tests.cpp` | Тесты производительности на матрице 2000×2000 |

## 6. Экспериментальная среда
| Компонент | Значение |
|-----------|----------|
| **Процессор** | Современный многоядерный CPU |
| **ОС** | Windows 10/11 |
| **Компилятор** | MSVC/GCC, C++23 |
| **MPI** | Microsoft MPI (MS-MPI) |
| **Размер тестовой матрицы** | 2000×2000 элементов |

## 7. Результаты и обсуждение
### 7.1 Корректность работы
**Функциональные тесты (7 тестов)**:
1. **Test 1**: Матрица 2×2 × вектор 2 → [17, 39] 
2. **Test 2**: Единичная матрица 3×3 × вектор 3 → [2, 3, 4] 
3. **Test 3**: Матрица 2×3 × вектор 3 → [22, 58] 
4. **Test 4**: Матрица 4×2 × вектор 2 → [5, 11, 17, 23] 
5. **Test 5**: Нулевая матрица 2×3 × вектор 3 → [0, 0] 
6. **Test 6**: Матрица 1×1 × вектор 1 → [7.5] 
7. **Test 7**: Матрица 1×5 × вектор 5 → [55] 

**Все 7 тестов успешно пройдены для SEQ и MPI версий!**

### 7.2 Производительность
Тестирование проводилось на матрице 2000×2000:

| Реализация | Процессов | Время (pipeline), сек | Время (task_run), сек | Ускорение |
|------------|-----------|----------------------|----------------------|-----------|
| **SEQ** | 1 | 0.0715 | 0.0721 | 1.00× |
| **MPI** | 2 | 0.1350 | 0.1382 | 0.53× |
| **MPI** | 4 | 0.1437 | 0.1360 | 0.50× |

**Анализ результатов**:
1. **SEQ версия** показывает стабильную производительность ~0.07 сек
2. **MPI версия** имеет накладные расходы на коммуникацию
3. Для матрицы 2000×2000 MPI не показывает преимущества из-за:
   - Накладных расходов MPI (пересылка данных, синхронизация)
   - Относительно небольшого размера задачи
   - Особенностей работы MS-MPI на Windows

**Ожидаемое ускорение на больших матрицах**:
- Для матриц >10000×10000 MPI должен показывать линейное ускорение
- Вертикальная схема эффективна при большом количестве столбцов

### 7.3 Особенности реализации
1. **Обработка граничных случаев**:
   - Если процессов больше чем столбцов, используется последовательный алгоритм
   - Проверка прямоугольности матрицы и соответствия размеров
   - Обработка пустых входных данных

2. **Оптимизации**:
   - Использование плоских массивов для эффективной рассылки
   - Минимизация коммуникационных операций
   - Локальная буферизация данных

## 8. Заключение
### Достигнутые результаты:
1.  Успешная реализация последовательного алгоритма умножения матрицы на вектор
2.  Корректная реализация MPI-версии с вертикальной ленточной схемой
3.  Полное покрытие функциональными тестами (7 тестов)
4.  Тестирование производительности на реалистичных данных
5.  Обработка всех граничных случаев
